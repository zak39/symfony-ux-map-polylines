// assets/controllers/mymap_controller.js

import { Controller } from '@hotwired/stimulus';

export default class extends Controller {
    connect() {
        this.element.addEventListener('ux:map:pre-connect', this._onPreConnect);
        this.element.addEventListener('ux:map:connect', this._onConnect);
        this.element.addEventListener('ux:map:marker:before-create', this._onMarkerBeforeCreate);
        this.element.addEventListener('ux:map:marker:after-create', this._onMarkerAfterCreate);
        this.element.addEventListener('ux:map:info-window:before-create', this._onInfoWindowBeforeCreate);
        this.element.addEventListener('ux:map:info-window:after-create', this._onInfoWindowAfterCreate);
    }

    disconnect() {
        // You should always remove listeners when the controller is disconnected to avoid side effects
        this.element.removeEventListener('ux:map:pre-connect', this._onPreConnect);
        this.element.removeEventListener('ux:map:connect', this._onConnect);
        this.element.removeEventListener('ux:map:marker:before-create', this._onMarkerBeforeCreate);
        this.element.removeEventListener('ux:map:marker:after-create', this._onMarkerAfterCreate);
        this.element.removeEventListener('ux:map:info-window:before-create', this._onInfoWindowBeforeCreate);
        this.element.removeEventListener('ux:map:info-window:after-create', this._onInfoWindowAfterCreate);
    }

    _onPreConnect(event) {
        // The map is not created yet
        // You can use this event to configure the map before it is created
        console.log(event.detail.options);
    }

    _onConnect(event) {
        // The map, markers and infoWindows are created
        // The instances depend on the renderer you are using
        console.log('ici pour event detail map', event.detail.map);
        console.log(event.detail.markers);
        console.log(event.detail.infoWindows);
        const map = event.detail.map
        
        var currentMode = null;
        var polylinePoints = [];
        var currentPolyline = null;
        // G√©n√©r√© par IA, peut √™tre utile, √† voir ?
        var allElements = []; // Stocke tous les Markers et Polylines
      
        function clearPolyline() {
          polylinePoints = [];
          currentPolyline = null;
        }
        
        var Toolbar = L.Control.extend({
            options: { position: 'topleft' },
        
            onAdd: function (map) {
              var container = L.DomUtil.create('div', 'leaflet-bar my-toolbar');
        
              var markerBtn = L.DomUtil.create('button', '', container);
              
              // work with Symfony UX Icons
              //markerBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.575 13.729C4.501 15.033 5.43 17 7.12 17h9.762c1.69 0 2.618-1.967 1.544-3.271l-4.881-5.927a2 2 0 0 0-3.088 0l-4.88 5.927Z" clip-rule="evenodd"/></svg>';  // Ic√¥ne Marker
              markerBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i>';  // Ic√¥ne Marker
        
              var polylineBtn = L.DomUtil.create('button', '', container);
              polylineBtn.innerHTML = '<i class="fas fa-draw-polygon"></i>';  // Ic√¥ne Polyline
        
              var deleteBtn = L.DomUtil.create('button', '', container);
              deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';  // Ic√¥ne Supprimer
        
              L.DomEvent.disableClickPropagation(container);
        
              // Fonction pour activer / d√©sactiver un bouton (toggle)
              function toggleMode(mode, button) {
                if (currentMode === mode) {
                  currentMode = null;
                  button.classList.remove('active');
                } else {
                  currentMode = mode;
                  markerBtn.classList.remove('active');
                  polylineBtn.classList.remove('active');
                  deleteBtn.classList.remove('active');
                  button.classList.add('active');
                }
        
                // Si on sort du mode polyline, on annule la polyline temporaire
                if (currentMode !== 'polyline') {
                  clearPolyline();
                }
              }
        
              markerBtn.onclick = function() {
                toggleMode('marker', markerBtn);
              };
        
              polylineBtn.onclick = function() {
                toggleMode('polyline', polylineBtn);
              };
        
              deleteBtn.onclick = function() {
                toggleMode('delete', deleteBtn);
              };
        
              return container;
            }
          });

          map.addControl(new Toolbar());

          map.on('click', function(e) {
            // Cr√©ation d'un √©l√©ment.

            // Si c'est le marker
            if (currentMode === 'marker') {
              var marker = L.marker(e.latlng).addTo(map).bindPopup('Nouveau Marker').openPopup();
              console.log('Il faut enregistrer le marker');
              // On ajout l'√©l√©ment dans une liste
              // allElements.push(marker);
        
              // Supprimer l'√©l√©ment marker
              marker.on('click', function(evt) {
                if (currentMode === 'delete') {
                  map.removeLayer(marker);
                  console.log('Il faut supprimer le motif');
                  /*
                  fetch('http://localhost:8000/remove-marker/1', {
                    method: 'DELETE',
                    mode: 'cors'
                  })
                    .then((res) => {
                        console.log('response fetch', res)
                    })
                    .catch((reason) => {
                        console.error('reason', reason)
                    })
                  */
                }
              });
        
            // Sinon si c'est le polyline
            } else if (currentMode === 'polyline') { 
              // On enregistre l'√©l√©ment actuel dans la liste "polylinePoints" (ex: [ [1.2323, 23.2323], [1.2525, 23.5055] ] )
              polylinePoints.push(e.latlng);

              if (currentPolyline) {
                currentPolyline.setLatLngs(polylinePoints);
                console.log('Il faut enregistrer le polyline');
              } else {
                currentPolyline = L.polyline(polylinePoints, {color: 'blue'}).addTo(map);
                allElements.push(currentPolyline);
        
                // Popup avec color picker
                if (currentMode !== 'delete') {
                    const popupContent = `
                      <div class="popup-content">
                        <label for="colorPicker">Choisir une couleur :</label><br>
                        <input type="color" id="colorPicker" value="#0000ff"><br>
                        <button id="applyColorBtn" class="popup-btn">Appliquer</button>
                      </div>
                    `;
                    currentPolyline.bindPopup(popupContent);
            
                    currentPolyline.on('popupopen', function() {
                      const colorPicker = document.getElementById('colorPicker');
                      const applyBtn = document.getElementById('applyColorBtn');
            
                      applyBtn.onclick = function() {
                        const selectedColor = colorPicker.value;
                        currentPolyline.setStyle({color: selectedColor});
                        currentPolyline.closePopup();
                      };
                    });
                }
        
                // Supprimer l'√©l√©ment polyline
                // Gestion suppression polyline
                currentPolyline.on('click', function(evt) {
                  if (currentMode === 'delete') {
                    map.removeLayer(currentPolyline);
                    console.log('Il faut supprimer le motif');
                    clearPolyline();
                  }
                });
              }
        
            }
          });

        /*
        map.pm.addControls({
            position: 'topleft',
            drawCircleMarker: false,
            rotateMode: false,
        })
        */

        const popup = L.popup({
            className: 'my-popup'
        });
        function onMapClick(e) {
            const lat = e.latlng.lat
            const lng = e.latlng.lng

            popup
            .setLatLng(e.latlng)

            .setContent("Voici les coordon√©es √† copier: " + lat + ", " + lng + "</br></br>")
            .openOn(map);

            const btn = document.createElement('button')
            btn.appendChild(document.createTextNode('Copier le point'))
            btn.addEventListener("click", function (e) {
                copyClipBoard(lat, lng)
                btn.innerText = 'Point pr√™t √† √™tre coll√© üëç'
            });

            popup._contentNode.appendChild(btn)
    
        }

        map.on('click', onMapClick);

        function copyClipBoard(lat, lng) {
            console.log('click click');
            const coordinate = lat + ', ' + lng
            navigator.clipboard.writeText(coordinate);
        }
    }

    _onMarkerBeforeCreate(event) {
        // The marker is not created yet
        // You can use this event to configure the marker before it is created
        console.log(event.detail.definition);
    }

    _onMarkerAfterCreate(event) {
        // The marker is created
        // The instance depends on the renderer you are using
        console.log(event.detail.marker);
        const btnDel = document.querySelector('.btn-remove')
        if (btnDel !== null) {
            console.debug('TEEEEEEEEEEEEEEEST')
            btnDel.addEventListener('click', function() {
                alert('Test')
                console.log('A supprimer')
            })
        }
    }

    _onInfoWindowBeforeCreate(event) {
        // The infoWindow is not created yet
        // You can use this event to configure the infoWindow before it is created
        console.log(event.detail.definition);
        // The associated marker instance is also available
        console.log(event.detail.marker);
    }

    _onInfoWindowAfterCreate(event) {
        // The infoWindow is created
        // The instance depends on the renderer you are using
        console.log(event.detail.infoWindow);
        // The associated marker instance is also available
        console.log(event.detail.marker);
    }
}